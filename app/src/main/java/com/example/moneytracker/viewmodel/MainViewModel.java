package com.example.moneytracker.viewmodel;import androidx.annotation.NonNull;import androidx.lifecycle.LiveData;import androidx.lifecycle.MediatorLiveData;import androidx.lifecycle.MutableLiveData;import androidx.lifecycle.Transformations;import androidx.lifecycle.ViewModel;import com.example.moneytracker.data.db.Account;import com.example.moneytracker.data.db.Category;import com.example.moneytracker.data.db.Transaction;import com.example.moneytracker.data.model.AccountWithBalance;import com.example.moneytracker.interfaces.IAccountRepository;import com.example.moneytracker.interfaces.ICategoryRepository;import com.example.moneytracker.interfaces.ITransactionRepository;import com.example.moneytracker.utils.DateUtils;import java.util.Calendar;import java.util.List;import javax.inject.Inject;import dagger.hilt.android.lifecycle.HiltViewModel;@HiltViewModelpublic class MainViewModel extends ViewModel {    private final ITransactionRepository transactionRepository;    private final IAccountRepository accountRepository;    private final ICategoryRepository categoryRepository;    private final MutableLiveData<Calendar> selectedDate = new MutableLiveData<>();    private final MutableLiveData<String> searchQuery = new MutableLiveData<>("");    private final MediatorLiveData<List<Transaction>> _filteredTransactions = new MediatorLiveData<>();    public final LiveData<List<Transaction>> filteredTransactions = _filteredTransactions;    public final LiveData<Double> incomeForPeriod;    public final LiveData<Double> expenseForPeriod;    public final LiveData<Double> totalBalance;    public final LiveData<String> selectedDateString;    public final LiveData<List<Category>> allCategories;    public final LiveData<List<AccountWithBalance>> allAccountsWithBalance;    private LiveData<List<Transaction>> currentDbSource = null;    @Inject    public MainViewModel(            ITransactionRepository transactionRepository,            ICategoryRepository categoryRepository,            IAccountRepository accountRepository    ) {        this.transactionRepository = transactionRepository;        this.categoryRepository = categoryRepository;        this.accountRepository = accountRepository;        this.allCategories = categoryRepository.getAllCategories();        this.allAccountsWithBalance = accountRepository.getAccountsWithBalance();        _filteredTransactions.addSource(selectedDate, date -> updateFilteredTransactions());        _filteredTransactions.addSource(searchQuery, query -> updateFilteredTransactions());        incomeForPeriod = Transformations.map(_filteredTransactions, transactions -> {            double income = 0.0;            if (transactions != null) {                for (Transaction t : transactions) {                    if (t.amount > 0) income += t.amount;                }            }            return income;        });        expenseForPeriod = Transformations.map(_filteredTransactions, transactions -> {            double expense = 0.0;            if (transactions != null) {                for (Transaction t : transactions) {                    if (t.amount < 0) expense += t.amount;                }            }            return expense;        });        totalBalance = Transformations.switchMap(selectedDate, date -> {            if (date == null) return new MutableLiveData<>();            long endOfDayTimestamp = DateUtils.getDayStartEndTimestamps(date)[1];            return transactionRepository.getTotalBalanceUpToDate(endOfDayTimestamp);        });        selectedDateString = Transformations.map(selectedDate, DateUtils::formatFullDateForHeader);        selectedDate.setValue(Calendar.getInstance());    }    private void updateFilteredTransactions() {        Calendar date = selectedDate.getValue();        String query = searchQuery.getValue();        if (date == null || query == null) {            return;        }        long[] dayRange = DateUtils.getDayStartEndTimestamps(date);        if (currentDbSource != null) {            _filteredTransactions.removeSource(currentDbSource);        }        currentDbSource = transactionRepository.getTransactionsByDateAndQuery(dayRange[0], dayRange[1], query);        _filteredTransactions.addSource(currentDbSource, _filteredTransactions::setValue);    }    public void setSearchQuery(String query) {        searchQuery.setValue(query);    }    public void setSelectedDate(Calendar calendar) {        if (calendar != null) {            selectedDate.setValue(calendar);        }    }    public Calendar getSelectedDate() {        return selectedDate.getValue();    }    public void addTransaction(String label, double amount, String type, Integer categoryId, int accountId) {        long timestamp = System.currentTimeMillis();        Transaction transaction = new Transaction(label, amount, timestamp, type, categoryId, accountId);        transactionRepository.insertTransaction(transaction);    }    public void updateTransaction(@NonNull Transaction transaction) {        transactionRepository.updateTransaction(transaction);    }    public void deleteTransaction(@NonNull Transaction transaction) {        transactionRepository.deleteTransaction(transaction);    }    public LiveData<Transaction> getTransactionById(int transactionId) {        return transactionRepository.getTransactionById(transactionId);    }}